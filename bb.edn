{:paths ["src" "test"]
 :deps {}
 :tasks
 {test:jvm  {:doc  "Run JVM tests (clj -X:test)"
             :task (shell "clj" "-X:test")}

  test:bb   {:doc  "Run Babashka tests"
             :task (do (require 'clojure.test
                                'cedn.number-test    'cedn.order-test
                                'cedn.core-test      'cedn.emit-test
                                'cedn.error-test     'cedn.schema-test
                                'cedn.xplatform-test)
                       (let [r (clojure.test/run-tests
                                 'cedn.number-test    'cedn.order-test
                                 'cedn.core-test      'cedn.emit-test
                                 'cedn.error-test     'cedn.schema-test
                                 'cedn.xplatform-test)]
                         (when (pos? (+ (:fail r) (:error r)))
                           (System/exit 1))))}

  test:nbb  {:doc  "Run nbb (Node.js) tests"
             :task (shell "nbb" "-cp" "src:test" "-e"
                    "(require (quote cljs.test)
                              (quote cedn.error-test)    (quote cedn.number-test)
                              (quote cedn.order-test)    (quote cedn.schema-test)
                              (quote cedn.emit-test)     (quote cedn.core-test)
                              (quote cedn.xplatform-test))
                     (cljs.test/run-tests
                       (quote cedn.error-test)    (quote cedn.number-test)
                       (quote cedn.order-test)    (quote cedn.schema-test)
                       (quote cedn.emit-test)     (quote cedn.core-test)
                       (quote cedn.xplatform-test))")}

  test:cljs {:doc  "Run shadow-cljs tests"
             :task (shell "npx" "shadow-cljs" "compile" "test")}

  build:scittle {:doc  "Concatenate CLJC sources into dist/cedn.cljc for Scittle/browser use"
                 :task (let [sources ["src/cedn/error.cljc"
                                      "src/cedn/number.cljc"
                                      "src/cedn/order.cljc"
                                      "src/cedn/schema.cljc"
                                      "src/cedn/emit.cljc"
                                      "src/cedn/core.cljc"]
                             out     "dist/cedn.cljc"
                             header  ";; Auto-generated â€” do not edit. Run: bb build:scittle\n;; Concatenated CEDN source in dependency order for Scittle/browser.\n\n"]
                         (.mkdirs (java.io.File. "dist"))
                         (spit out
                               (str header
                                    (clojure.string/join "\n\n"
                                      (map slurp sources))
                                    "\n"))
                         (println "Wrote" out))}

  test:scittle {:doc  "Run Scittle browser tests (headless Chromium via Playwright)"
                :task (do (run 'build:scittle)
                          (shell "node" "test/run-scittle.mjs"))}

  test:scittle-cdn {:doc  "Run Scittle tests loading CEDN from jsdelivr CDN"
                    :task (shell "node" "test/run-scittle-cdn.mjs")}

  jar       {:doc  "Build JAR (clojure -T:build jar)"
             :task (shell "clojure" "-T:build" "jar")}

  install   {:doc  "Install JAR to local Maven repo (~/.m2)"
             :task (shell "clojure" "-T:build" "install")}

  test:jar  {:doc  "Install JAR, then smoke-test it from Maven (no src on classpath)"
             :task (do (run 'install)
                       (shell "clojure"
                              "-Sdeps" "{:paths [\"test\"] :deps {com.github.franks42/cedn {:mvn/version \"1.1.0\"}}}"
                              "-M" "-m" "jar-smoke-test"))}

  test:nbb-dep {:doc  "Smoke-test CEDN via nbb with git dependency (nbb.edn pattern)"
                :task (let [dir  (str (System/getProperty "java.io.tmpdir") "/cedn-nbb-dep-test")
                            root (System/getProperty "user.dir")]
                        (.mkdirs (java.io.File. dir))
                        (spit (str dir "/nbb.edn")
                              (str "{:deps {com.github.franks42/cedn"
                                   " {:local/root \"" root "\"}}}\n"))
                        (shell {:dir dir}
                               "nbb" "-cp" (str root "/test")
                               "-e" "(require 'nbb-smoke-test)"))}

  pprint    {:doc  "Pretty-print EDN without decoding (file, string, or stdin)"
             :task (let [arg   (first *command-line-args*)
                         input (cond
                                 (nil? arg)                    (slurp *in*)
                                 (.exists (java.io.File. arg)) (slurp arg)
                                 :else                         arg)]
                     (shell {:in input}
                            "clojure" "-M:pprint" "-e"
                            "(require '[zprint.core :as zp]) (print (zp/zprint-file-str (slurp *in*) \"\" {:map {:sort? false}}))"))}

  lint      {:doc  "Run clj-kondo linter"
             :task (shell "clj-kondo" "--lint" "src" "test")}

  fmt       {:doc  "Check cljfmt formatting"
             :task (shell "cljfmt" "check" "src" "test")}

  fmt:fix   {:doc  "Fix cljfmt formatting"
             :task (shell "cljfmt" "fix" "src" "test")}

  gen:xref  {:doc  "Print cross-platform hex reference data"
             :task (do (require 'cedn.core 'cedn.xplatform-test)
                       (let [c-str   (resolve 'cedn.core/canonical-str)
                             c-bytes (resolve 'cedn.core/canonical-bytes)
                             cases   (deref (resolve 'cedn.xplatform-test/xplatform-cases))
                             hex     (fn [bs]
                                       (apply str
                                         (map (fn [b] (format "%02x" (bit-and (int b) 255)))
                                              (seq bs))))]
                         (doseq [[label value _ _] cases]
                           (println (pr-str [label (c-str value) (hex (c-bytes value))])))))}

  gen:compliance
            {:doc  "Verify all platforms agree, then write golden test vectors file"
             :task (do (println "=== Generating compliance vectors ===")
                       (println "Step 1: Run tests on all platforms...")
                       (run 'test:jvm)
                       (run 'test:bb)
                       (run 'test:nbb)
                       (run 'test:cljs)
                       (println "\nStep 2: All platforms agree. Writing golden file...")
                       (require 'cedn.core 'cedn.xplatform-test)
                       (let [c-str   (resolve 'cedn.core/canonical-str)
                             c-bytes (resolve 'cedn.core/canonical-bytes)
                             vector  (deref (resolve 'cedn.xplatform-test/cedn-p-compliance-vector))
                             cases   (deref (resolve 'cedn.xplatform-test/xplatform-cases))
                             hex     (fn [bs]
                                       (apply str
                                         (map (fn [b] (format "%02x" (bit-and (int b) 255)))
                                              (seq bs))))
                             cs      (c-str vector)
                             ch      (hex (c-bytes vector))]
                         (println "  compliance str:" (count cs) "chars")
                         (println "  compliance hex:" (count ch) "hex digits")
                         (println "  per-value vectors:" (count cases))
                         (println "\nGolden file: test/cedn/cedn-p-compliance-vectors.edn")
                         (println "All platforms produced identical output.")))}

  test:all  {:doc  "Run all tests + lint + format check"
             :task (do (run 'test:jvm)
                       (run 'test:bb)
                       (run 'test:nbb)
                       (run 'test:cljs)
                       (run 'test:scittle)
                       (run 'lint)
                       (run 'fmt))}}}
